// Direkter Vergleich im ITTF-Modus
tmp->ExecuteUpdate(str = 
  "CREATE FUNCTION [dbo].[IttfSortDirectCompFunc]  \n"
  "(	  \n"
  "	@syID " + INTEGER + ",  \n"
  "	@grID " + INTEGER + ",  \n"
  "	@ids " + VARCHAR + "(200)  \n"
  ")  \n"
  "RETURNS @t TABLE   \n"
  "(  \n"
  "	grID " + INTEGER + ",  \n"
  "	stID " + INTEGER + ",  \n"
  "	stPos " + SMALLINT + ",  \n"
  "	mtBallsA " + SMALLINT + ",  \n"
  "	mtBallsX " + SMALLINT + ",  \n"
  "	mtSetsA  " + SMALLINT + ",  \n"
  "	mtSetsX  " + SMALLINT + ",  \n"
  "	mtMatchesA " + SMALLINT + ",  \n"
  "	mtMatchesX " + SMALLINT + ",  \n"
  "	mtPointsA  " + SMALLINT + ",  \n"
  "	mtPointsX  " + SMALLINT + ",  \n"
  "	mtMatchCount  " + SMALLINT + ",  \n"
  "	mtMatchPoints " + SMALLINT + "  \n"
  ")  \n"
  "AS  \n"
  "BEGIN  \n"
  "	--- Sumup all matches  \n"
  "	INSERT INTO @t (grID, stID, stPos,   \n"
  "					mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,   \n"
  "					mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints)  \n"
  "		SELECT	grID, stID, 0,   \n"
  "				mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,  \n"
  "				mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints   \n"
  "		  FROM  SumUpFunc(@grID, @ids)  \n"
  "  \n"
  "	--- Number the matches  \n"
  "	DECLARE @stID " + INTEGER + "  \n"
  "	DECLARE @stPos " + SMALLINT + "  \n"
  "  \n"
  "	--- First by match points  \n"
  "	DECLARE stMatchPointsCursor CURSOR FOR  \n"
  "		(SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "		  WHERE dbo.DiffFunc(t1.mtMatchPoints, 0, t2.mtMatchPoints, 0) > 0  \n"
  "		  GROUP BY t1.stID) ORDER BY (2)  \n"
  "	  \n"
  "	OPEN stMatchPointsCursor  \n"
  "	FETCH NEXT FROM stMatchPointsCursor INTO @stID, @stPos  \n"
  "	WHILE (@@FETCH_STATUS = 0)  \n"
  "	BEGIN  \n"
  "		UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "		FETCH NEXT FROM stMatchPointsCursor INTO @stID, @stPos  \n"
  "	END  \n"
  "  \n"
  "	--- If not separated, sort teams by matches  \n"
  "	IF (@syID > 0 AND (SELECT MIN(stPos) FROM @t) = (SELECT MAX(stPos) FROM @t))  \n"
  "	BEGIN  \n"
  "		--- First by match points  \n"
  "		DECLARE stMatchesCursor CURSOR FOR  \n"
  "			(SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "			  WHERE dbo.QuotFunc(t1.mtMatchesA, t1.mtMatchesX, t2.mtMatchesA, t2.mtMatchesX) > 0  \n"
  "			  GROUP BY t1.stID) ORDER BY (2)  \n"
  "		  \n"
  "		OPEN stMatchesCursor  \n"
  "		FETCH NEXT FROM stMatchesCursor INTO @stID, @stPos  \n"
  "		WHILE (@@FETCH_STATUS = 0)  \n"
  "		BEGIN  \n"
  "			UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "			FETCH NEXT FROM stMatchesCursor INTO @stID, @stPos  \n"
  "		END  \n"
  "	END  \n"
  "  \n"
  "	--- If not separated, sort by sets  \n"
  "	IF ((SELECT MIN(stPos) FROM @t) = (SELECT MAX(stPos) FROM @t))  \n"
  "	BEGIN  \n"
  "		--- First by match points  \n"
  "		DECLARE stSetsCursor CURSOR FOR  \n"
  "			(SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "			  WHERE dbo.QuotFunc(t1.mtSetsA, t1.mtSetsX, t2.mtSetsA, t2.mtSetsX) > 0  \n"
  "			  GROUP BY t1.stID) ORDER BY (2)  \n"
  "		  \n"
  "		OPEN stSetsCursor  \n"
  "		FETCH NEXT FROM stSetsCursor INTO @stID, @stPos  \n"
  "		WHILE (@@FETCH_STATUS = 0)  \n"
  "		BEGIN  \n"
  "			UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "			FETCH NEXT FROM stSetsCursor INTO @stID, @stPos  \n"
  "		END  \n"
  "	END  \n"
  "  \n"
  "	--- And finally by balls, if not yet separated  \n"
  "	IF ((SELECT MIN(stPos) FROM @t) = (SELECT MAX(stPos) FROM @t))  \n"
  "	BEGIN  \n"
  "		--- First by match points  \n"
  "		DECLARE stBallsCursor CURSOR FOR  \n"
  "			(SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "			  WHERE dbo.QuotFunc(t1.mtBallsA, t1.mtBallsX, t2.mtBallsA, t2.mtBallsX) > 0  \n"
  "			  GROUP BY t1.stID) ORDER BY (2)  \n"
  "		  \n"
  "		OPEN stBallsCursor  \n"
  "		FETCH NEXT FROM stBallsCursor INTO @stID, @stPos  \n"
  "		WHILE (@@FETCH_STATUS = 0)  \n"
  "		BEGIN  \n"
  "			UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "			FETCH NEXT FROM stBallsCursor INTO @stID, @stPos  \n"
  "		END  \n"
  "	END  \n"
  "  \n"
  "  \n"
  "	--- If still not separated, return  \n"
  "	IF ((SELECT MIN(stPos) FROM @t) = (SELECT MAX(stPos) FROM @t))  \n"
  "		RETURN  \n"
  "  \n"
  "	--- Now do the recursion  \n"
  "	DECLARE @lastStPos " + SMALLINT + "  \n"
  "	DECLARE @lastStID  " + INTEGER + "  \n"
  "	DECLARE @compIds  " + VARCHAR + "(200)  \n"
  "  \n"
  "	SET @lastStPos = -1  \n"
  "	SET @compIds = ''  \n"
  "  \n"
  "	DECLARE stRecurseCursor CURSOR FOR  \n"
  "		(SELECT stID, stPos FROM @t) ORDER BY (2)  \n"
  "	OPEN stRecurseCursor  \n"
  "	FETCH NEXT FROM stRecurseCursor INTO @stID, @stPos  \n"
  "	WHILE (@@FETCH_STATUS = 0)  \n"
  "	BEGIN  \n"
  "		IF (@stPos = @lastStPos)  \n"
  "		BEGIN  \n"
  "			--- Duplicate stPos: Go to a direct compare and number those equal.  \n"
  "			--- To avoid problems at the end, we don't wait until the position  \n"
  "			--- changes again (that won't happen if the last two are equal),   \n"
  "			--- but we do it for every equal numbers.  \n"
  "			SET @compIds = @compIds + CAST(@stID AS " + VARCHAR + "(10)) + ','  \n"
  "  \n"
  "			DECLARE @stCompID  " + INTEGER + "  \n"
  "			DECLARE @stCompPos " + SMALLINT + "  \n"
  "  \n"
  "			DECLARE stDirectCompCursor CURSOR FOR  \n"
  "				(SELECT stID, stPos FROM dbo.IttfSortDirectCompFunc(@syID, @grID, @compIds))  \n"
  "			OPEN stDirectCompCursor  \n"
  "			FETCH NEXT FROM stDirectCompCursor INTO @stCompID, @stCompPos  \n"
  "			WHILE (@@FETCH_STATUS = 0)  \n"
  "			BEGIN  \n"
  "				--- New number is old position + relative position  \n"
  "				UPDATE @t SET stPos = @stPos + @stCompPos WHERE stID = @stCompID  \n"
  "				FETCH NEXT FROM stDirectCompCursor INTO @stCompID, @stCompPos  \n"
  "			END  \n"
  "  \n"
  "			CLOSE stDirectCompCursor  \n"
  "			DEALLOCATE stDirectCompCursor  \n"
  "		END  \n"
  "		ELSE  \n"
  "		BEGIN  \n"
  "			SET @compIds = CAST(@stID AS " + VARCHAR + "(10)) + ','  \n"
  "		END  \n"
  "  \n"
  "		SET @lastStPos = @stPos  \n"
  "  \n"
  "	    FETCH NEXT FROM stRecurseCursor INTO @stID, @stPos  \n"
  "	END  \n"
  "	  \n"
  "	RETURN  \n"
  "END  \n"
);

  
// Tabellenberechnung im ITTF-Modus
tmp->ExecuteUpdate(str = 
  "CREATE FUNCTION IttfSortFunc  \n"
  "(	  \n"
  "	 @grID " + INTEGER + ",  \n"
  "  @ids "  + VARCHAR + "(200)  \n"
  ")  \n"
  "RETURNS @t TABLE   \n"
  "(  \n"
  "	 grID	INT,  \n"
  "	 stID	INT,  \n"
  "	 stPos 	SMALLINT,  \n"
  "	 mtBallsA " + SMALLINT + ",  \n"
  "	 mtBallsX " + SMALLINT + ",  \n"
  "	 mtSetsA  " + SMALLINT + ",  \n"
  "	 mtSetsX  " + SMALLINT + ",  \n"
  "	 mtMatchesA " + SMALLINT + ",  \n"
  "	 mtMatchesX " + SMALLINT + ",  \n"
  "	 mtPointsA  " + SMALLINT + ",  \n"
  "	 mtPointsX  " + SMALLINT + ",  \n"
  "	 mtMatchCount  " + SMALLINT + ",  \n"
  "	 mtMatchPoints " + SMALLINT + "  \n"
  ")  \n"
  "AS  \n"
  "BEGIN  \n"
  "	 DECLARE @syID " + INTEGER + "  \n"
  "	 SET @syID = (SELECT syID FROM GrRec WHERE grID = @grID)  \n"
  "  \n"
  "  \n"
  "	 DECLARE @stID " + INTEGER + "  \n"
  "	 DECLARE @stPos " + SMALLINT + "  \n"
  "  \n"
  "	--- Sumup all matches  \n"
  "	 INSERT INTO @t (grID, stID, stPos,   \n"
  "					 mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,   \n"
  "					 mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints)  \n"
  "	 SELECT	grID, stID, 0,   \n"
  "				  mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,  \n"
  "				  mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints   \n"
  "		 FROM  SumUpFunc(@grID, @ids)  \n"
  "  \n"
  "	 --- Sort by mtMatchPoints only  \n"
  "	 DECLARE stPosCursor CURSOR FOR  \n"
  "		 (SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "		   WHERE dbo.DiffFunc(t1.mtMatchPoints, 0, t2.mtMatchPoints, 0) > 0  \n"
  "		   GROUP BY t1.stID) ORDER BY (2)  \n"
  "  \n"
  "	 OPEN stPosCursor  \n"
  "	 FETCH NEXT FROM stPosCursor INTO @stID, @stPos  \n"
  "	 WHILE (@@FETCH_STATUS = 0)  \n"
  "	 BEGIN  \n"
  "	 --- Update stPos (preliminary)  \n"
  "	   UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "    \n"
  "		 FETCH NEXT FROM stPosCursor INTO @stID, @stPos  \n"
  "	 END  \n"
  "  \n"
  "	 --- Number the matches  \n"
  "  --- We loop through all results and if we find a duplicate position, \n"
  "  --- we go to the direct compare of those found so far. \n"
  "	 DECLARE @lastStPos " + SMALLINT + "  \n"
  "	 SET @lastStPos = -1  \n"
  "  \n"
  "	 DECLARE @compIds " + VARCHAR + "(200)  \n"
  "	 SET @compIds = ''  \n"
  "  \n"
  "	 DECLARE stRecurseCursor CURSOR FOR (SELECT stID, stPos FROM @t) ORDER BY (2)  \n"
  "	 OPEN stRecurseCursor  \n"
  "	 FETCH NEXT FROM stRecurseCursor INTO @stID, @stPos  \n"
  "	 WHILE (@@FETCH_STATUS = 0)  \n"
  "	 BEGIN  \n"
  "		 IF (@stPos = @lastStPos)  \n"
  "		 BEGIN  \n"
  "			 --- Duplicate stPos: Go to a direct compare and renumber those equal.  \n"
  "			 --- To avoid problems at the end, we don't wait until the position  \n"
  "			 --- changes again (that won't happen if the last two are equal),   \n"
  "			 --- but we do it for every equal numbers.  \n"
  "			 SET @compIds = @compIds + CAST(@stID AS " + VARCHAR + "(10)) + ','  \n"
  "      \n"
  "			 DECLARE @stCompID  " + INTEGER + "  \n"
  "			 DECLARE @stCompPos " + SMALLINT + "  \n"
  "      \n"
  "			 DECLARE stDirectCompCursor CURSOR FOR  \n"
  "				  (SELECT stID, stPos FROM dbo.IttfSortDirectCompFunc(@syID, @grID, @compIds))  \n"
  "			 OPEN stDirectCompCursor  \n"
  "			 FETCH NEXT FROM stDirectCompCursor INTO @stCompID, @stCompPos  \n"
  "			 WHILE (@@FETCH_STATUS = 0)  \n"
  "			 BEGIN  \n"
  "				 --- New number is old position + relative position  \n"
  "				 UPDATE @t SET stPos = @stPos + @stCompPos WHERE stID = @stCompID  \n"
  "				 FETCH NEXT FROM stDirectCompCursor INTO @stCompID, @stCompPos  \n"
  "			 END  \n"
  "      \n"
  "			 CLOSE stDirectCompCursor  \n"
  "			 DEALLOCATE stDirectCompCursor  \n"
  "		 END  \n"
  "		 ELSE  \n"
  "		 BEGIN  \n"
  "			 SET @compIds = CAST(@stID AS " + VARCHAR + "(10)) + ','  \n"
  "		 END  \n"
  "    \n"
  "		 SET @lastStPos = @stPos  \n"
  "    \n"
  "		 FETCH NEXT FROM stRecurseCursor INTO @stID, @stPos  \n"
  "	 END  \n"
  "  \n"
  "	--- And now normalize to 1  \n"
  "	 UPDATE @t SET stPos = stPos + 1  WHERE stID IS NOT NULL \n"
  "	 RETURN  \n"
  "END  \n"
);  
