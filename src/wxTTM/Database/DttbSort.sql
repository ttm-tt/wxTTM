
// Erster Vergleich im DTTB-Modus
tmp->ExecuteUpdate(str = 
  "CREATE OR ALTER FUNCTION DttbCompFunc  \n"
  "(  \n"
	"  @syID " + INTEGER + ",  \n"
	"  @mtMatchPoints1 " + SMALLINT + ",  \n"
	"  @mtMatchPoints2 " + SMALLINT + ",  \n"
	"  @mtPointsA1 " + SMALLINT + ",  \n"
	"  @mtPointsX1 " + SMALLINT + ",  \n"
	"  @mtPointsA2 " + SMALLINT + ",  \n"
	"  @mtPointsX2 " + SMALLINT + ",  \n"
	"  @mtMatchesA1 " + SMALLINT + ",  \n"
	"  @mtMatchesX1 " + SMALLINT + ",  \n"
	"  @mtMatchesA2 " + SMALLINT + ",  \n"
	"  @mtMatchesX2 " + SMALLINT + ",  \n"
	"  @mtSetsA1 " + SMALLINT + ",  \n"
	"  @mtSetsX1 " + SMALLINT + ",  \n"
	"  @mtSetsA2 " + SMALLINT + ",  \n"
	"  @mtSetsX2 " + SMALLINT + ",  \n"
	"  @mtBallsA1 " + SMALLINT + ",  \n"
	"  @mtBallsX1 " + SMALLINT + ",  \n"
	"  @mtBallsA2 " + SMALLINT + ",  \n"
	"  @mtBallsX2 " + SMALLINT + "  \n"
  ")  \n"
  "RETURNS " + SMALLINT + "  \n"
  "AS  \n"
  "BEGIN  \n"
	"  DECLARE @res " + SMALLINT + "  \n"
  "  \n"
//  Put players without any matches or points (byes) to the end
    "  IF ((@mtPointsA1 + @mtPointsX1) = 0 AND (@mtPointsA2 + @mtPointsX2) > 0) \n"
	"      RETURN +1 \n"
	"  ELSE IF ((@mtPointsA1 + @mtPointsX1) > 0 AND (@mtPointsA2 + @mtPointsX2) = 0) \n"
	"      RETURN -1 \n"
	"  ELSE IF ((@mtPointsA1 + @mtPointsX1) = 0 AND (@mtPointsA2 + @mtPointsX2) = 0) \n"
	"      RETURN 0 \n"
  "  \n"
	"  IF (@syID > 0)  \n"
	"  BEGIN  \n"
	"	  --- Team matches  \n"
// Larger plus pts, lesser minus pts, larger diff of plus and minus pts, sets, balls
	"     SET @res = (@mtPointsA2 - @mtPointsA1) \n"
	"     IF (@res <> 0) \n"
	"         RETURN @res \n"
  "  \n"
	"     SET @res = (@mtPointsX1 - @mtPointsX2) \n"
	"     IF (@res <> 0) \n"
	"         RETURN @res \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtMatchesA1, @mtMatchesX1, @mtMatchesA2, @mtMatchesX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtSetsA1, @mtSetsX1, @mtSetsA2, @mtSetsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtBallsA1, @mtBallsX1, @mtBallsA2, @mtBallsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
	"  END  \n"
	"  ELSE  \n"
	"  BEGIN  \n"
	"	  --- Individual matches  \n"
// Larger plus pts, lesser minus pts, larger diff of plus and minus pts, sets, balls
	"     SET @res = (@mtPointsA2 - @mtPointsA1) \n"
	"     IF (@res <> 0) \n"
	"         RETURN @res \n"
  "  \n"
	"     SET @res = (@mtPointsX1 - @mtPointsX2) \n"
	"     IF (@res <> 0) \n"
	"         RETURN @res \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtSetsA1, @mtSetsX1, @mtSetsA2, @mtSetsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtBallsA1, @mtBallsX1, @mtBallsA2, @mtBallsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
	"  END  \n"
  "  \n"
	"  RETURN 0  \n"
  "END  \n"
);  


// Vergleich zweier Ergebnisse im direkten Vergleich
tmp->ExecuteUpdate(str = 
  "CREATE OR ALTER FUNCTION DttbDirectCompFunc  \n"
  "(  \n"
	"  @syID " + INTEGER + ",  \n"
	"  @mtMatchPoints1 " + SMALLINT + ",  \n"
	"  @mtMatchPoints2 " + SMALLINT + ",  \n"
	"  @mtPointsA1 " + SMALLINT + ",  \n"
	"  @mtPointsX1 " + SMALLINT + ",  \n"
	"  @mtPointsA2 " + SMALLINT + ",  \n"
	"  @mtPointsX2 " + SMALLINT + ",  \n"
	"  @mtMatchesA1 " + SMALLINT + ",  \n"
	"  @mtMatchesX1 " + SMALLINT + ",  \n"
	"  @mtMatchesA2 " + SMALLINT + ",  \n"
	"  @mtMatchesX2 " + SMALLINT + ",  \n"
	"  @mtSetsA1 " + SMALLINT + ",  \n"
	"  @mtSetsX1 " + SMALLINT + ",  \n"
	"  @mtSetsA2 " + SMALLINT + ",  \n"
	"  @mtSetsX2 " + SMALLINT + ",  \n"
	"  @mtBallsA1 " + SMALLINT + ",  \n"
	"  @mtBallsX1 " + SMALLINT + ",  \n"
	"  @mtBallsA2 " + SMALLINT + ",  \n"
	"  @mtBallsX2 " + SMALLINT + "  \n"
  ")  \n"
  "RETURNS " + SMALLINT + "  \n"
  "AS  \n"
  "BEGIN  \n"
	"  DECLARE @res " + SMALLINT + "  \n"
  "  \n"
	"  IF (@syID > 0)  \n"
	"  BEGIN  \n"
	"	  --- Nothing to do for team matches  \n"
	"	  RETURN 0  \n"
	"  END  \n"
	"  ELSE  \n"
	"  BEGIN  \n"
	"	  --- Individual matches  \n"
	"	  SET @res = dbo.DiffFunc(@mtPointsA1, @mtPointsX1, @mtPointsA2, @mtPointsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtSetsA1, @mtSetsX1, @mtSetsA2, @mtSetsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
  "  \n"
	"	  SET @res = dbo.DiffFunc(@mtBallsA1, @mtBallsX1, @mtBallsA2, @mtBallsX2)  \n"
	"	  IF (@res <> 0)  \n"
	"		  RETURN @res  \n"
	"  END  \n"
  "  \n"
	"  RETURN 0  \n"
  "END  \n"
);  

// Sortierung im direkten Vergleich im DTTB-Modus
tmp->ExecuteUpdate(str = 
  "CREATE OR ALTER FUNCTION DttbSortDirectCompFunc  \n"
  "(	  \n"
  "	@syID " + INTEGER + ",  \n"
  "	@grID " + INTEGER + ",  \n"
  "	@ids " + VARCHAR + "(200)  \n"
  ")  \n"
  "RETURNS @t TABLE   \n"
  "(  \n"
  "	grID " + INTEGER + ",  \n"
  "	stID " + INTEGER + ",  \n"
  "	stPos " + SMALLINT + ",  \n"
  "	mtBallsA " + SMALLINT + ",  \n"
  "	mtBallsX " + SMALLINT + ",  \n"
  "	mtSetsA  " + SMALLINT + ",  \n"
  "	mtSetsX  " + SMALLINT + ",  \n"
  "	mtMatchesA " + SMALLINT + ",  \n"
  "	mtMatchesX " + SMALLINT + ",  \n"
  "	mtPointsA  " + SMALLINT + ",  \n"
  "	mtPointsX  " + SMALLINT + ",  \n"
  "	mtMatchCount  " + SMALLINT + ",  \n"
  "	mtMatchPoints " + SMALLINT + "  \n"
  ")  \n"
  "AS  \n"
  "BEGIN  \n"
  "	--- Sumup all matches  \n"
  "	INSERT INTO @t (grID, stID, stPos,   \n"
  "					mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,   \n"
  "					mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints)  \n"
  "		SELECT	grID, stID, 0,   \n"
  "				mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,  \n"
  "				mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints   \n"
  "		  FROM  SumUpFunc(@grID, @ids)  \n"
  "  \n"
  "	--- Nothing to do for team matches  \n"
  "	IF (@syID > 0)  \n"
  "		RETURN  \n"
  "  \n"
  "	--- Number the matches, no recursion  \n"
  "	DECLARE @stID " + INTEGER + "  \n"
  "	DECLARE @stPos " + SMALLINT + "  \n"
  "  \n"
  "	DECLARE stPosCursor CURSOR FOR  \n"
  "		(SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "		  WHERE dbo.DttbDirectCompFunc(  \n"
  "					@syID, t1.mtMatchPoints, t2.mtMatchPoints,  \n"
  "					t1.mtPointsA, t1.mtPointsX, t2.mtPointsA, t2.mtPointsX,   \n"
  "					t1.mtMatchesA, t1.mtMatchesX, t2.mtMatchesA, t2.mtMatchesX,  \n"
  "					t1.mtSetsA, t1.mtSetsX, t2.mtSetsA, t2.mtSetsX,  \n"
  "					t1.mtBallsA, t1.mtBallsX, t2.mtBallsA, t2.mtBallsX) > 0  \n"
  "		  GROUP BY t1.stID) ORDER BY (2)  \n"
  "	  \n"
  "	OPEN stPosCursor  \n"
  "	FETCH NEXT FROM stPosCursor INTO @stID, @stPos  \n"
  "	WHILE (@@FETCH_STATUS = 0)  \n"
  "	BEGIN  \n"
  "		UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "		FETCH NEXT FROM stPosCursor INTO @stID, @stPos  \n"
  "	END  \n"
  "	  \n"
  "	RETURN  \n"
  "END  \n"
);  
  
// Berechnet eine Tabelle im DTTB-Modus
tmp->ExecuteUpdate(str = 
  "CREATE OR ALTER FUNCTION DttbSortFunc  \n"
  "(	  \n"
  "	@grID " + INTEGER + ",  \n"
  " @ids " + VARCHAR + "(200) \n"
  ")  \n"
  "RETURNS @t TABLE   \n"
  "(  \n"
  "	grID "+ INTEGER + ",  \n"
  "	stID " + INTEGER + ",  \n"
  "	stPos " + SMALLINT + ",  \n"
  "	mtBallsA " + SMALLINT + ",  \n"
  "	mtBallsX " + SMALLINT + ",  \n"
  "	mtSetsA  " + SMALLINT + ",  \n"
  "	mtSetsX  " + SMALLINT + ",  \n"
  "	mtMatchesA " + SMALLINT + ",  \n"
  "	mtMatchesX " + SMALLINT + ",  \n"
  "	mtPointsA  " + SMALLINT + ",  \n"
  "	mtPointsX  " + SMALLINT + ",  \n"
  "	mtMatchCount  " + SMALLINT + ",  \n"
  "	mtMatchPoints " + SMALLINT + "  \n"
  ")  \n"
  "AS  \n"
  "BEGIN  \n"
  "	DECLARE @syID " + INTEGER + "  \n"
  "	SET @syID = (SELECT syID FROM GrRec WHERE grID = @grID)  \n"
  "  \n"
  "	DECLARE @stID " + INTEGER + "  \n"
  "	DECLARE @stPos " + SMALLINT + "  \n"
  "  \n"
  "	--- Sumup all matches  \n"
  "	INSERT INTO @t (grID, stID, stPos,   \n"
  "					mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,   \n"
  "					mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints)  \n"
  "		SELECT	grID, stID, 0,   \n"
  "				mtBallsA, mtBallsX, mtSetsA, mtSetsX, mtMatchesA, mtMatchesX,  \n"
  "				mtPointsA, mtPointsX, mtMatchCount, mtMatchPoints   \n"
  "		  FROM  SumUpFunc(@grID, @ids)  \n"
  "  \n"
  "	--- Number the matches  \n"
  "	DECLARE @lastStPos " + SMALLINT + "  \n"
  "	SET @lastStPos = -1  \n"
  "  \n"
  "	DECLARE @compIds "+ VARCHAR + "(200)  \n"
  "	SET @compIds = ''  \n"
  "  \n"
  "	DECLARE stPosCursor CURSOR FOR  \n"
  "		(SELECT t1.stID, COUNT(*) FROM @t t1, @t t2   \n"
  "		  WHERE dbo.DttbCompFunc(  \n"
  "					@syID, t1.mtMatchPoints, t2.mtMatchPoints,  \n"
  "					t1.mtPointsA, t1.mtPointsX, t2.mtPointsA, t2.mtPointsX,   \n"
  "					t1.mtMatchesA, t1.mtMatchesX, t2.mtMatchesA, t2.mtMatchesX,  \n"
  "					t1.mtSetsA, t1.mtSetsX, t2.mtSetsA, t2.mtSetsX,  \n"
  "					t1.mtBallsA, t1.mtBallsX, t2.mtBallsA, t2.mtBallsX) > 0  \n"
  "		  GROUP BY t1.stID) ORDER BY (2)  \n"
  "  \n"
  "	OPEN stPosCursor  \n"
  "	FETCH NEXT FROM stPosCursor INTO @stID, @stPos  \n"
  "	WHILE (@@FETCH_STATUS = 0)  \n"
  "	BEGIN  \n"
  "		--- Update stPos (preliminary)  \n"
  "		UPDATE @t SET stPos = @stPos WHERE stID = @stID  \n"
  "  \n"
  "		FETCH NEXT FROM stPosCursor INTO @stID, @stPos  \n"
  "	END  \n"
  "  \n"
  "	DECLARE stRecurseCompCursor CURSOR FOR (SELECT stID, stPos FROM @t) ORDER BY (2)  \n"
  "	OPEN stRecurseCompCursor  \n"
  "	FETCH NEXT FROM stRecurseCompCursor INTO @stID, @stPos  \n"
  "	WHILE (@@FETCH_STATUS = 0)  \n"
  "	BEGIN  \n"
  "		IF (@stPos = @lastStPos)  \n"
  "		BEGIN  \n"
  "			--- Duplicate stPos: Go to a direct compare and number those equal.  \n"
  "			--- To avoid problems at the end, we don't wait until the position  \n"
  "			--- changes again (that won't happen if the last two are equal),   \n"
  "			--- but we do it for every equal numbers.  \n"
  "			SET @compIds = @compIds + CAST(@stID AS " + VARCHAR + "(10)) + ','  \n"
  "  \n"
  "			DECLARE @stCompID  " + INTEGER + "  \n"
  "			DECLARE @stCompPos " + SMALLINT + "  \n"
  "  \n"
  "			DECLARE stDirectCompCursor CURSOR FOR  \n"
  "				(SELECT stID, stPos FROM dbo.DttbSortDirectCompFunc(@syID, @grID, @compIds))  \n"
  "			OPEN stDirectCompCursor  \n"
  "			FETCH NEXT FROM stDirectCompCursor INTO @stCompID, @stCompPos  \n"
  "			WHILE (@@FETCH_STATUS = 0)  \n"
  "			BEGIN  \n"
  "				--- New number is old position + relative position  \n"
  "				UPDATE @t SET stPos = @stPos + @stCompPos WHERE stID = @stCompID  \n"
  "				FETCH NEXT FROM stDirectCompCursor INTO @stCompID, @stCompPos  \n"
  "			END  \n"
  "  \n"
  "			CLOSE stDirectCompCursor  \n"
  "			DEALLOCATE stDirectCompCursor  \n"
  "		END  \n"
  "		ELSE  \n"
  "		BEGIN  \n"
  "			SET @compIds = CAST(@stID AS " + VARCHAR + "(10)) + ','  \n"
  "		END  \n"
  "  \n"
  "		SET @lastStPos = @stPos  \n"
  "  \n"
  "		FETCH NEXT FROM stRecurseCompCursor INTO @stID, @stPos  \n"
  "	END  \n"
  "  \n"
  "	--- And now normalize to 1  \n"
  "	UPDATE @t SET stPos = stPos + 1  WHERE stID IS NOT NULL \n"
  "	RETURN  \n"
  "END  \n"
);  
